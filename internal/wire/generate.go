package wire

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
	"time"
)

type Generator struct {
	components []Component
	visited    map[string]bool
}

type templateData struct {
	Imports    []string
	Components []componentInit
}

type componentInit struct {
	VarName      string
	Type         string
	Package      string
	Dependencies []componentDep
	Interfaces   []interfaceReg
}

type componentDep struct {
	FieldName string
	VarName   string
}

type interfaceReg struct {
	Interface string
	Qualifier string
	VarName   string
}

func NewGenerator(components []Component) *Generator {
	return &Generator{
		components: components,
		visited:    make(map[string]bool),
	}
}

func (g *Generator) Generate(baseDir string) error {
	startTime := time.Now()

	if len(g.components) == 0 {
		return fmt.Errorf("no components found")
	}

	// Create wire directory if it doesn't exist
	wireDir := filepath.Join(baseDir, "wire")
	if err := os.MkdirAll(wireDir, 0755); err != nil {
		return fmt.Errorf("failed to create wire directory: %w", err)
	}

	// Order components by dependencies before generating initializations
	orderedComponents := g.orderComponentsByDependencies()
	inits := g.generateComponentInits(orderedComponents)

	// Define template functions
	funcMap := template.FuncMap{
		"base": func(pkg string) string {
			parts := strings.Split(pkg, "/")
			return parts[len(parts)-1]
		},
	}

	// Create and parse template
	tmpl := template.New("wire").Funcs(funcMap)
	tmpl, err := tmpl.Parse(`// File: wire_gen.go
// Code generated by Go IoC. DO NOT EDIT.
//go:generate go run github.com/tuhuynh27/go-ioc/cmd/generate -dir=../
package wire

import ({{range .Imports}}
    "{{.}}"{{end}}
)

// Application holds all the wired components
type Application struct {
    {{- range $comp := .Components}}
    {{$comp.VarName}} *{{$comp.Package | base}}.{{$comp.Type}}
    {{- end}}
}

// Initialize creates and wires all components
func Initialize() *Application {
    app := &Application{}
    {{- range $comp := .Components}}
    app.{{$comp.VarName}} = &{{$comp.Package | base}}.{{$comp.Type}}{
        {{- range $dep := $comp.Dependencies}}
        {{$dep.FieldName}}: app.{{$dep.VarName}},
        {{- end}}
    }
    {{- end}}
    return app
}

{{- range $comp := .Components}}
// Get{{$comp.Type}} returns the {{$comp.Type}} instance
func (app *Application) Get{{$comp.Type}}() *{{$comp.Package | base}}.{{$comp.Type}} {
    return app.{{$comp.VarName}}
}
{{- end}}`)
	if err != nil {
		return fmt.Errorf("template parsing failed: %w", err)
	}

	// Get unique imports
	imports := make(map[string]bool)
	for _, comp := range g.components {
		// Only add valid import paths (must contain at least one '/')
		if strings.Contains(comp.Package, "/") && comp.Package != "github.com/tuhuynh27/go-ioc/ioc" {
			imports[comp.Package] = true
		}
		// Add imports for interfaces
		for _, iface := range comp.Implements {
			if idx := strings.LastIndex(iface, "."); idx != -1 {
				pkgPath := iface[:idx]
				if strings.Contains(pkgPath, "/") && pkgPath != "github.com/tuhuynh27/go-ioc/ioc" {
					imports[pkgPath] = true
				}
			}
		}
	}

	// Convert imports map to sorted slice
	var importSlice []string
	for imp := range imports {
		importSlice = append(importSlice, imp)
	}
	sort.Strings(importSlice)

	// Prepare template data
	data := templateData{
		Imports:    importSlice,
		Components: inits,
	}

	// Execute template
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("template execution failed: %w", err)
	}

	// Write the generated code to the file
	outputPath := filepath.Join(wireDir, "wire_gen.go")
	if err := os.WriteFile(outputPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write generated code: %w", err)
	}

	log.Printf("Generated wire_gen.go in %s (completed in %v)", wireDir, time.Since(startTime))
	return nil
}

func (g *Generator) findPackageForType(pkgName string) string {
	for _, comp := range g.components {
		if strings.HasSuffix(comp.Package, "/"+pkgName) {
			return comp.Package
		}
	}
	return ""
}

func (g *Generator) generateComponentInits(components []Component) []componentInit {
	var inits []componentInit
	varNames := make(map[string]string)
	nameCount := make(map[string]int)

	// First pass: create meaningful variable names for all components
	for _, comp := range components {
		baseName := comp.Type
		baseName = strings.ToLower(baseName[:1]) + baseName[1:]

		count := nameCount[baseName]
		nameCount[baseName]++

		varName := baseName
		if count > 0 {
			varName = fmt.Sprintf("%s%d", baseName, count+1)
		}

		varNames[comp.Package+"."+comp.Type] = varName
	}

	// Second pass: create component initializations with interface registrations
	for _, comp := range components {
		init := componentInit{
			VarName:      varNames[comp.Package+"."+comp.Type],
			Type:         comp.Type,
			Package:      comp.Package,
			Dependencies: []componentDep{},
			Interfaces:   []interfaceReg{},
		}

		// Add dependencies
		for _, dep := range comp.Dependencies {
			depVarName := ""
			depType := dep.Type

			if strings.Contains(depType, ".") {
				parts := strings.Split(depType, ".")
				pkgName := parts[0]
				interfaceName := parts[1]

				// Find matching component for the dependency
				for _, c := range components {
					if strings.HasSuffix(c.Package, pkgName) {
						// For other interfaces, check implementation
						for _, impl := range c.Implements {
							if strings.HasSuffix(impl, interfaceName) && c.Qualifier == dep.Qualifier {
								depVarName = varNames[c.Package+"."+c.Type]
								break
							}
						}
						// Also check if component type matches interface name directly
						if c.Type == interfaceName && c.Qualifier == dep.Qualifier {
							depVarName = varNames[c.Package+"."+c.Type]
							break
						}
					}
				}
			} else {
				// Handle non-interface dependencies by direct type matching
				for _, c := range components {
					if c.Type == depType {
						depVarName = varNames[c.Package+"."+c.Type]
						break
					}
				}
			}

			if depVarName != "" {
				init.Dependencies = append(init.Dependencies, componentDep{
					FieldName: dep.FieldName,
					VarName:   depVarName,
				})
			} else {
				log.Printf("Warning: Could not find component for dependency %s with qualifier %s", dep.Type, dep.Qualifier)
			}
		}

		// Add interface registrations
		for _, iface := range comp.Implements {
			init.Interfaces = append(init.Interfaces, interfaceReg{
				Interface: iface,
				Qualifier: comp.Qualifier,
				VarName:   init.VarName,
			})
		}

		inits = append(inits, init)
	}

	return inits
}

func (g *Generator) logDependencies(comp Component) {
	log.Printf("Processing component: %s", comp.Type)
}

// Helper function to check if a slice contains a string
func contains(slice []string, str string) bool {
	for _, s := range slice {
		if strings.HasSuffix(s, str) {
			return true
		}
	}
	return false
}

func (g *Generator) orderComponentsByDependencies() []Component {
	var ordered []Component
	g.visited = make(map[string]bool)

	// Start with components that have no dependencies
	for _, comp := range g.components {
		if len(comp.Dependencies) == 0 && !g.visited[comp.Package+"."+comp.Type] {
			g.dfsVisit(comp, &ordered)
		}
	}

	// Process remaining components
	for _, comp := range g.components {
		if !g.visited[comp.Package+"."+comp.Type] {
			g.dfsVisit(comp, &ordered)
		}
	}

	return ordered
}

func (g *Generator) dfsVisit(comp Component, ordered *[]Component) {
	g.visited[comp.Package+"."+comp.Type] = true

	// Visit dependencies first
	for _, dep := range comp.Dependencies {
		if strings.Contains(dep.Type, ".") {
			parts := strings.Split(dep.Type, ".")
			pkgName := parts[0]
			typeName := parts[1]

			// Find and visit dependency component
			for _, other := range g.components {
				if strings.HasSuffix(other.Package, pkgName) {
					// Handle both direct type matches and interface implementations
					if other.Type == typeName || contains(other.Implements, typeName) {
						if !g.visited[other.Package+"."+other.Type] {
							g.dfsVisit(other, ordered)
						}
					}
				}
			}
		}
	}

	*ordered = append(*ordered, comp)
}
